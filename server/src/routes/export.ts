/**
 * Policy Export endpoint
 * 
 * Generates enforcement-ready policy bundles from finalized contracts.
 * Decoupled from /finalize to maintain clean authority boundaries.
 * 
 * Supported formats:
 * - opa_bundle: Open Policy Agent bundle (policy.rego + data.json)
 * - policy_json: Raw policy JSON for custom enforcement engines
 * 
 * Design principles:
 * - Idempotent: Same inputs â†’ same artifact hash
 * - Decoupled: Export is separate from contract finalization
 * - Extensible: New formats can be added without changing /finalize
 */

import { Router, Request, Response } from 'express';
import { canonicalize, computeHash } from '@ddr/meta-engine';
import { ENGINE_VERSION, ARTIFACT_SCHEMA_VERSION } from '../index';

export const exportRouter = Router();

type ExportFormat = 'opa_bundle' | 'policy_json';

interface ExportPolicyRequest {
  contract_id: string;
  canonical_json: Record<string, unknown>;
  format: ExportFormat;
  target_version?: string;
}

interface OPABundle {
  policy_rego: string;
  data_json: Record<string, unknown>;
  manifest: {
    revision: string;
    roots: string[];
  };
}

/**
 * Generate OPA Rego policy from DCG contract
 */
function generateOPAPolicy(contract: Record<string, unknown>, contractId: string): string {
  const framing = contract.framing as Record<string, unknown> | undefined;
  const rules = contract.rules as { rules: Array<Record<string, unknown>> } | undefined;
  const policies = contract.policies as { policies: Array<Record<string, unknown>> } | undefined;
  const outputs = contract.outputs as { outputs: Array<Record<string, unknown>> } | undefined;

  const decisionName = (framing?.decision_name as string) || 'decision';
  const packageName = decisionName.toLowerCase().replace(/[^a-z0-9_]/g, '_');

  let rego = `# DCG Generated Policy
# Contract ID: ${contractId}
# Generated by DCG Engine v${ENGINE_VERSION}
# DO NOT EDIT - This file is auto-generated

package dcg.${packageName}

import future.keywords.if
import future.keywords.in
import future.keywords.contains

# =============================================================================
# Contract Metadata
# =============================================================================

contract_id := "${contractId}"
engine_version := "${ENGINE_VERSION}"
artifact_schema_version := "${ARTIFACT_SCHEMA_VERSION}"

# =============================================================================
# Default Decision
# =============================================================================

default allow := false
default decision := "REFUSE"
default reason_code := "NO_MATCHING_RULE"

`;

  // Generate output codes as constants
  if (outputs?.outputs && Array.isArray(outputs.outputs)) {
    rego += `# =============================================================================
# Valid Output Codes
# =============================================================================

valid_output_codes := {
`;
    outputs.outputs.forEach((output: Record<string, unknown>, i: number) => {
      const code = output.code as string;
      const comma = i < outputs.outputs.length - 1 ? ',' : '';
      rego += `  "${code}"${comma}\n`;
    });
    rego += `}

`;
  }

  // Generate policy constraints
  if (policies?.policies && Array.isArray(policies.policies)) {
    rego += `# =============================================================================
# Policy Constraints
# =============================================================================

`;
    policies.policies.forEach((policy: Record<string, unknown>, i: number) => {
      const name = (policy.name as string) || `policy_${i}`;
      const safeName = name.toLowerCase().replace(/[^a-z0-9_]/g, '_');
      const description = policy.description as string || '';
      
      rego += `# Policy: ${name}
# ${description}
policy_${safeName}_active := true

`;
    });
  }

  // Generate rules
  if (rules?.rules && Array.isArray(rules.rules)) {
    rego += `# =============================================================================
# Decision Rules
# =============================================================================

`;
    rules.rules.forEach((rule: Record<string, unknown>, i: number) => {
      const name = (rule.name as string) || `rule_${i}`;
      const safeName = name.toLowerCase().replace(/[^a-z0-9_]/g, '_');
      const outputCode = rule.output_code as string || 'UNKNOWN';
      const reasonCode = rule.reason_code as string || '';
      const condition = rule.condition as Record<string, unknown> | undefined;
      
      rego += `# Rule: ${name}\n`;
      
      if (condition) {
        const leftOperand = condition.left_operand as string || 'true';
        const operator = condition.operator as string || 'EQUALS';
        const rightOperand = condition.right_operand as string || 'true';
        
        // Convert DCG condition to Rego
        let regoCondition = 'true';
        const inputRef = leftOperand.replace('input.', 'input.');
        
        switch (operator) {
          case 'EQUALS':
            regoCondition = `${inputRef} == ${JSON.stringify(rightOperand)}`;
            break;
          case 'NOT_EQUALS':
            regoCondition = `${inputRef} != ${JSON.stringify(rightOperand)}`;
            break;
          case 'GREATER_THAN':
            regoCondition = `${inputRef} > ${rightOperand}`;
            break;
          case 'LESS_THAN':
            regoCondition = `${inputRef} < ${rightOperand}`;
            break;
          case 'GREATER_THAN_OR_EQUALS':
            regoCondition = `${inputRef} >= ${rightOperand}`;
            break;
          case 'LESS_THAN_OR_EQUALS':
            regoCondition = `${inputRef} <= ${rightOperand}`;
            break;
          case 'IS_PRESENT':
            regoCondition = `${inputRef}`;
            break;
          case 'IS_ABSENT':
            regoCondition = `not ${inputRef}`;
            break;
          case 'IN':
            regoCondition = `${inputRef} in ${rightOperand}`;
            break;
          default:
            regoCondition = 'true';
        }
        
        rego += `rule_${safeName}_matches if {
  ${regoCondition}
}

decision := "${outputCode}" if {
  rule_${safeName}_matches
}

`;
        if (reasonCode) {
          rego += `reason_code := "${reasonCode}" if {
  rule_${safeName}_matches
}

`;
        }
      }
    });
  }

  // Add allow rule
  rego += `# =============================================================================
# Allow Rule (for OPA decision API)
# =============================================================================

allow if {
  decision != "REFUSE"
}
`;

  return rego;
}

/**
 * Generate OPA data.json from DCG contract
 */
function generateOPAData(contract: Record<string, unknown>, contractId: string): Record<string, unknown> {
  return {
    dcg: {
      contract_id: contractId,
      engine_version: ENGINE_VERSION,
      artifact_schema_version: ARTIFACT_SCHEMA_VERSION,
      contract: contract,
    },
  };
}

/**
 * POST /api/v1/export/policy
 * 
 * Generate enforcement-ready policy bundle from a finalized contract.
 * 
 * Request:
 * {
 *   "contract_id": "dcg.contract.age_gate.v1",
 *   "canonical_json": { ... },
 *   "format": "opa_bundle" | "policy_json",
 *   "target_version": "0.58.0" (optional, for OPA compatibility)
 * }
 * 
 * Response:
 * {
 *   "artifact_type": "dcg_policy_bundle",
 *   "artifact_hash": "sha256:...",
 *   "format": "opa_bundle",
 *   "bundle": { ... },
 *   "engine_version": "1.0.0",
 *   "timestamp": "..."
 * }
 */
exportRouter.post('/policy', async (req: Request, res: Response) => {
  try {
    const { contract_id, canonical_json, format = 'opa_bundle', target_version } = req.body as ExportPolicyRequest;

    // Validate request
    if (!contract_id) {
      return res.status(400).json({
        error: 'MISSING_CONTRACT_ID',
        message: 'contract_id is required',
        engine_version: ENGINE_VERSION,
        timestamp: new Date().toISOString(),
      });
    }

    if (!canonical_json) {
      return res.status(400).json({
        error: 'MISSING_CANONICAL_JSON',
        message: 'canonical_json is required',
        engine_version: ENGINE_VERSION,
        timestamp: new Date().toISOString(),
      });
    }

    if (!['opa_bundle', 'policy_json'].includes(format)) {
      return res.status(400).json({
        error: 'INVALID_FORMAT',
        message: `format must be one of: opa_bundle, policy_json`,
        engine_version: ENGINE_VERSION,
        timestamp: new Date().toISOString(),
      });
    }

    console.log(`[EXPORT] Generating ${format} for contract: ${contract_id}`);

    if (format === 'opa_bundle') {
      // Generate OPA bundle
      const policyRego = generateOPAPolicy(canonical_json, contract_id);
      const dataJson = generateOPAData(canonical_json, contract_id);
      
      const bundle: OPABundle = {
        policy_rego: policyRego,
        data_json: dataJson,
        manifest: {
          revision: contract_id,
          roots: ['dcg'],
        },
      };

      // Compute bundle hash for idempotency
      const bundleCanonical = canonicalize(bundle as unknown as Record<string, unknown>);
      const bundleHash = await computeHash(bundleCanonical);

      console.log(`[EXPORT] OPA bundle generated. Hash: ${bundleHash}`);

      return res.json({
        artifact_type: 'dcg_policy_bundle',
        artifact_hash: bundleHash,
        format: 'opa_bundle',
        contract_id,
        target_version: target_version || 'latest',
        bundle,
        engine_version: ENGINE_VERSION,
        artifact_schema_version: ARTIFACT_SCHEMA_VERSION,
        timestamp: new Date().toISOString(),
      });
    } else {
      // Generate raw policy JSON
      const policyJson = {
        contract_id,
        contract: canonical_json,
        enforcement_ready: true,
      };

      const policyCanonical = canonicalize(policyJson);
      const policyHash = await computeHash(policyCanonical);

      console.log(`[EXPORT] Policy JSON generated. Hash: ${policyHash}`);

      return res.json({
        artifact_type: 'dcg_policy_json',
        artifact_hash: policyHash,
        format: 'policy_json',
        contract_id,
        policy: policyJson,
        engine_version: ENGINE_VERSION,
        artifact_schema_version: ARTIFACT_SCHEMA_VERSION,
        timestamp: new Date().toISOString(),
      });
    }
  } catch (err) {
    console.error('[EXPORT] Error:', err);
    return res.status(500).json({
      error: 'EXPORT_ERROR',
      message: err instanceof Error ? err.message : String(err),
      engine_version: ENGINE_VERSION,
      timestamp: new Date().toISOString(),
    });
  }
});

/**
 * GET /api/v1/export/formats
 * 
 * List available export formats.
 */
exportRouter.get('/formats', (_req: Request, res: Response) => {
  res.json({
    formats: [
      {
        id: 'opa_bundle',
        name: 'Open Policy Agent Bundle',
        description: 'OPA-compatible policy bundle with policy.rego and data.json',
        outputs: ['policy_rego', 'data_json', 'manifest'],
      },
      {
        id: 'policy_json',
        name: 'Policy JSON',
        description: 'Raw policy JSON for custom enforcement engines',
        outputs: ['policy'],
      },
    ],
    engine_version: ENGINE_VERSION,
    artifact_schema_version: ARTIFACT_SCHEMA_VERSION,
  });
});
